// Copyright Â© Spelldawn 2021-present

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//    https://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package spelldawn;
option csharp_namespace = "Spelldawn.Protos";

import "google/protobuf/wrappers.proto";
import "google/protobuf/any.proto";


// ============================================================================
// Masonry
// ============================================================================


enum FlexAlign {
    FLEX_ALIGN_UNSPECIFIED = 0;
    FLEX_ALIGN_AUTO = 1;
    FLEX_ALIGN_FLEX_START = 2;
    FLEX_ALIGN_CENTER = 3;
    FLEX_ALIGN_FLEX_END = 4;
    FLEX_ALIGN_STRETCH = 5;
}

enum FlexDisplayStyle {
    FLEX_DISPLAY_STYLE_UNSPECIFIED = 0;
    FLEX_DISPLAY_STYLE_FLEX = 1;
    FLEX_DISPLAY_STYLE_NONE = 2;
}

enum FlexDirection {
    FLEX_DIRECTION_UNSPECIFIED = 0;
    FLEX_DIRECTION_COLUMN = 1;
    FLEX_DIRECTION_COLUMN_REVERSE = 2;
    FLEX_DIRECTION_ROW = 3;
    FLEX_DIRECTION_ROW_REVERSE = 4;
}

enum FlexWrap {
    FLEX_WRAP_UNSPECIFIED = 0;
    FLEX_WRAP_NO_WRAP = 1;
    FLEX_WRAP_WRAP = 2;
    FLEX_WRAP_WRAP_REVERSE = 3;
}

enum FlexJustify {
    FLEX_JUSTIFY_UNSPECIFIED = 0;
    FLEX_JUSTIFY_FLEX_START = 1;
    FLEX_JUSTIFY_CENTER = 2;
    FLEX_JUSTIFY_FLEX_END = 3;
    FLEX_JUSTIFY_SPACE_BETWEEN = 4;
    FLEX_JUSTIFY_SPACE_AROUND = 5;
}

enum FlexOverflow {
    FLEX_OVERFLOW_UNSPECIFIED = 0;
    FLEX_OVERFLOW_VISIBLE = 1;
    FLEX_OVERFLOW_HIDDEN = 2;
}

enum FlexPosition {
    FLEX_POSITION_UNSPECIFIED = 0;
    FLEX_POSITION_RELATIVE = 1;
    FLEX_POSITION_ABSOLUTE = 2;
}

enum TextOverflow {
    TEXT_OVERFLOW_UNSPECIFIED = 0;
    TEXT_OVERFLOW_CLIP = 1;
    TEXT_OVERFLOW_ELLIPSIS = 2;
}

enum EasingMode {
    EASING_MODE_UNSPECIFIED = 0;
    EASING_MODE_EASE = 1;
    EASING_MODE_EASE_IN = 2;
    EASING_MODE_EASE_OUT = 3;
    EASING_MODE_EASE_IN_OUT = 4;
    EASING_MODE_LINEAR = 5;
    EASING_MODE_EASE_IN_SINE = 6;
    EASING_MODE_EASE_OUT_SINE = 7;
    EASING_MODE_EASE_IN_OUT_SINE = 8;
    EASING_MODE_EASE_IN_CUBIC = 9;
    EASING_MODE_EASE_OUT_CUBIC = 10;
    EASING_MODE_EASE_IN_OUT_CUBIC = 11;
    EASING_MODE_EASE_IN_CIRC = 12;
    EASING_MODE_EASE_OUT_CIRC = 13;
    EASING_MODE_EASE_IN_OUT_CIRC = 14;
    EASING_MODE_EASE_IN_ELASTIC = 15;
    EASING_MODE_EASE_OUT_ELASTIC = 16;
    EASING_MODE_EASE_IN_OUT_ELASTIC = 17;
    EASING_MODE_EASE_IN_BACK = 18;
    EASING_MODE_EASE_OUT_BACK = 19;
    EASING_MODE_EASE_IN_OUT_BACK = 20;
    EASING_MODE_EASE_IN_BOUNCE = 21;
    EASING_MODE_EASE_OUT_BOUNCE = 22;
    EASING_MODE_EASE_IN_OUT_BOUNCE = 23;
}

enum ImageScaleMode {
    IMAGE_SCALE_MODE_UNSPECIFIED = 0;
    IMAGE_SCALE_MODE_STRETCH_TO_FILL = 1;
    IMAGE_SCALE_MODE_SCALE_AND_CROP = 2;
    IMAGE_SCALE_MODE_SCALE_TO_FIT = 3;
}

enum FontStyle {
    FONT_STYLE_UNSPECIFIED = 0;
    FONT_STYLE_NORMAL = 1;
    FONT_STYLE_BOLD = 2;
    FONT_STYLE_ITALIC = 3;
    FONT_STYLE_BOLD_AND_ITALIC = 4;
}

enum OverflowClipBox {
    OVERFLOW_CLIP_BOX_UNSPECIFIED = 0;
    OVERFLOW_CLIP_BOX_PADDING_BOX = 1;
    OVERFLOW_CLIP_BOX_CONTENT_BOX = 2;
}

enum TextAlign {
    TEXT_ALIGN_UNSPECIFIED = 0;
    TEXT_ALIGN_UPPER_LEFT = 1;
    TEXT_ALIGN_UPPER_CENTER = 2;
    TEXT_ALIGN_UPPER_RIGHT = 3;
    TEXT_ALIGN_MIDDLE_LEFT = 4;
    TEXT_ALIGN_MIDDLE_CENTER = 5;
    TEXT_ALIGN_MIDDLE_RIGHT = 6;
    TEXT_ALIGN_LOWER_LEFT = 7;
    TEXT_ALIGN_LOWER_CENTER = 8;
    TEXT_ALIGN_LOWER_RIGHT = 9;
}

enum TextOverflowPosition {
    TEXT_OVERFLOW_POSITION_UNSPECIFIED = 0;
    TEXT_OVERFLOW_POSITION_END = 1;
    TEXT_OVERFLOW_POSITION_START = 2;
    TEXT_OVERFLOW_POSITION_MIDDLE = 3;
}

enum FlexVisibility {
    FLEX_VISIBILITY_UNSPECIFIED = 0;
    FLEX_VISIBILITY_VISIBLE = 1;
    FLEX_VISIBILITY_HIDDEN = 2;
}

enum WhiteSpace {
    WHITE_SPACE_UNSPECIFIED = 0;
    WHITE_SPACE_NORMAL = 1;
    WHITE_SPACE_NO_WRAP = 2;
}

message FlexColor {
    /** Red color component, specified in the range 0.0 to 1.0 inclusive. */
    float red = 1;

    /** Green color component, specified in the range 0.0 to 1.0 inclusive. */
    float green = 2;

    /** Blue color component, specified in the range 0.0 to 1.0 inclusive. */
    float blue = 3;

    /** 
     * Alpha color component, specified in the range 0.0 (transparent) to 1.0
     * (opaque) inclusive.
     */
    float alpha = 4;
}

message SpriteAddress {
    string address = 1;
}

message FontAddress {
    string address = 1;
}

message ProjectileAddress {
    string address = 1;
}

message EffectAddress {
    string address = 1;
}

message AudioClipAddress {
    string address = 1;
}

message FlexVector2 {
    float x = 1;
    float y = 2;
}

message FlexVector3 {
    float x = 1;
    float y = 2;
    float z = 3;
}

enum DimensionUnit {
    DIMENSION_UNIT_UNSPECIFIED = 0;
    /** Density-independent pixels, which unity also calls "pixels". */
    DIMENSION_UNIT_DIP = 1;
    DIMENSION_UNIT_PERCENTAGE = 2;
    DIMENSION_UNIT_VMIN = 3;
}

message Dimension {
    DimensionUnit unit = 1;
    float value = 2;
}

message DimensionGroup {
    Dimension top = 1;
    Dimension right = 2;
    Dimension bottom = 3;
    Dimension left = 4;
}

message BorderWidth {
    float top = 1;
    float right = 2;
    float bottom = 3;
    float left = 4;
}

message BorderColor {
    FlexColor top = 1;
    FlexColor right = 2;
    FlexColor bottom = 3;
    FlexColor left = 4;
}

message BorderRadius {
    Dimension top_left = 1;
    Dimension top_right = 2;
    Dimension bottom_right = 3;
    Dimension bottom_left = 4;
}

message FlexRotate {
    float degrees = 1;
}

message FlexTranslate {
    Dimension x = 1;
    Dimension y = 2;
    float z = 3;
}

message FlexScale {
    FlexVector3 amount = 1;
}

message TextShadow {
    FlexVector2 offset = 1;
    float blur_radius = 2;
    FlexColor color = 3;
}

message TimeValue {
    uint32 milliseconds = 1;
}

message ImageSlice {
    uint32 top = 1;
    uint32 right = 2;
    uint32 bottom = 3;
    uint32 left = 4;
}

message FlexStyle {
    FlexAlign align_content = 1;
    FlexAlign align_items = 2;
    FlexAlign align_self = 3;
    FlexColor background_color = 4;
    SpriteAddress background_image = 5;
    BorderColor border_color = 6;
    BorderRadius border_radius = 7;
    BorderWidth border_width = 8;
    DimensionGroup inset = 9;
    FlexColor color = 10;
    FlexDisplayStyle display = 11;
    Dimension flex_basis = 12;
    FlexDirection flex_direction = 13;
    google.protobuf.FloatValue flex_grow = 14;
    google.protobuf.FloatValue flex_shrink = 15;
    FlexWrap wrap = 16;
    Dimension font_size = 17;
    Dimension height = 18;
    FlexJustify justify_content = 19;
    Dimension letter_spacing = 20;
    DimensionGroup margin = 21;
    Dimension max_height = 22;
    Dimension max_width = 23;
    Dimension min_height = 24;
    Dimension min_width = 25;
    google.protobuf.FloatValue opacity = 26;
    FlexOverflow overflow = 27;
    DimensionGroup padding = 28;
    FlexPosition position = 29;
    FlexRotate rotate = 30;
    FlexScale scale = 31;
    TextOverflow text_overflow = 32;
    TextShadow text_shadow = 33;
    FlexTranslate transform_origin = 34;
    repeated TimeValue transition_delays = 35;
    repeated TimeValue transition_durations = 36;
    repeated string transition_properties = 37;
    repeated EasingMode transition_easing_modes = 38;
    FlexTranslate translate = 39;
    FlexColor background_image_tint_color = 40;
    ImageScaleMode background_image_scale_mode = 41;
    FontAddress font = 42;
    FontStyle font_style = 43;
    OverflowClipBox overflow_clip_box = 44;
    Dimension paragraph_spacing = 45;
    ImageSlice image_slice = 46;
    TextAlign text_align = 47;
    FlexColor text_outline_color = 48;
    google.protobuf.FloatValue text_outline_width = 49;
    TextOverflowPosition text_overflow_position = 50;
    FlexVisibility visibility = 51;
    WhiteSpace white_space = 52;
    Dimension width = 53;
    Dimension word_spacing = 54;

    /**
    * Overwrites both 'width' and 'height' by multiplying the dimensions of
    * the provided 'background_image' (in units of raw pixels) by this
    * constant.
    */
    google.protobuf.FloatValue background_image_scale_multiplier = 55;

    /**
    * Calculates the aspect ratio of the provided 'background_image' and uses
    * it to set dimensions. If 'width' is set, the 'height' will be set based
    * on the aspect ratio and vice versa. Does not support percentage values.
    */
    bool fixed_background_image_aspect_ratio = 56;
}

message Flexbox {
}

message Text {
    string label = 1;
}

message EventHandlers {
    GameAction on_click = 1;
}

message NodeType {
    oneof type {
        Text text = 1;
    }
}

message Node {
    /**
    * Used to identify this node in the hierarchy, should be unique among
    * siblings. If not provided, index will be used instead.
    */
    string id = 1;

    /**
    * Used to identify this node in debugging tools
    */
    string name = 2;

    NodeType node_type = 3;

    repeated Node children = 4;

    EventHandlers event_handlers = 5;

    FlexStyle style = 6;
    FlexStyle hover_style = 7;
    FlexStyle pressed_style = 8;
}


// ============================================================================
// Game Primitives
// ============================================================================

message GameId {
    uint64 value = 1;
}

enum PlayerName {
    PLAYER_NAME_UNSPECIFIED = 0;
    PLAYER_NAME_USER = 1;
    PLAYER_NAME_OPPONENT = 2;
}

message CardId {
    uint32 side = 1;
    uint32 index = 2;
}

message GameObjectId {
    oneof id {
        CardId card_id = 1;
        PlayerName identity = 2;
        PlayerName deck = 3;
        PlayerName hand = 4;
        PlayerName discard_pile = 5;
    }
}

enum RoomId {
    ROOM_ID_UNSPECIFIED = 0;
    ROOM_ID_VAULT = 1;
    ROOM_ID_SANCTUM = 2;
    ROOM_ID_CRYPTS = 3;
    ROOM_ID_ROOM_A = 4;
    ROOM_ID_ROOM_B = 5;
    ROOM_ID_ROOM_C = 6;
    ROOM_ID_ROOM_D = 7;
    ROOM_ID_ROOM_E = 8;
}


// ============================================================================
// Game View
// ============================================================================


message CardIcon {
    /** Background for the icon. */
    SpriteAddress background = 1;
    /** Text to display on the icon. */
    string text = 2;
    /** 
     * Scale for the background image to render at. A value of 0.0 will be
     * treated as 1.0
     */
    float background_scale = 3;
}

message CardIcons {
    CardIcon top_left_icon = 1;
    CardIcon top_right_icon = 2;
    CardIcon bottom_right_icon = 3;
    CardIcon bottom_left_icon = 4;
    CardIcon arena_icon = 5;
}

message CardTitle {
    string text = 1;
}

message RulesText {
    string text = 1;
}

enum TargetingArrow {
    TARGETING_ARROW_UNSPECIFIED = 0;
    TARGETING_ARROW_RED = 1;
    TARGETING_ARROW_BLUE = 2;
    TARGETING_ARROW_GREEN = 3;
}

/** This card should prompt for a room to be played into. */
message PickRoom {
}

message CardTargeting {
    oneof targeting {
        PickRoom pick_room = 1;
    }
}

enum CanPlayAlgorithm {
    CAN_PLAY_ALGORITHM_UNSPECIFIED = 0;

    /**
    * Always update the 'can_play' state automatically based on available mana
    * and actions.
    */
    CAN_PLAY_ALGORITHM_OPTIMISTIC = 1;

    /**
    * 'Optimistic False' algorithm for cards with an additional cost. Will
    * transition the 'can_play' state to false based on available mana and
    * actions, but not to true.
    */
    CAN_PLAY_ALGORITHM_ADDITIONAL_COST = 2;

    /**
    * 'Optimistic True' algorithm, for cards which can always be played for
    * their normal cost, but have other valid play windows as well. Will
    * transition the 'can_play' state to true based on available mana and
    * actions, but not to false.
    */
    CAN_PLAY_ALGORITHM_ADDITIONAL_PLAY = 3;

    /**
    * Do not transition the 'can_play' state automatically
    */
    CAN_PLAY_ALGORITHM_NO_UPDATE = 4;
}

enum SpendCostAlgorithm {
    SPEND_COST_ALGORITHM_UNSPECIFIED = 0;

    /** Deduct the mana & action cost immediately when this card is played. */
    SPEND_COST_ALGORITHM_OPTIMISTIC = 1;

    /** Do not modify mana & action values when this card is played. */
    SPEND_COST_ALGORITHM_NO_UPDATE = 2;
}

message CardCost {
    /** Mana cost for the card, 0 is used to represent 'no cost'. */
    uint32 mana_cost = 1;

    uint32 action_cost = 2;

    bool can_play = 3;

    CanPlayAlgorithm can_play_algorithm = 4;

    SpendCostAlgorithm spend_cost_algorithm = 5;
}

message ObjectPositionOffscreen {
}

enum RoomLocation {
    ROOM_LOCATION_UNSPECIFIED = 0;
    ROOM_LOCATION_BACK = 1;
    ROOM_LOCATION_FRONT = 2;
}

message ObjectPositionRoom {
    RoomId room_id = 1;
    RoomLocation room_location = 2;
}

enum ItemLocation {
    ITEM_LOCATION_UNSPECIFIED = 0;
    ITEM_LOCATION_LEFT = 1;
    ITEM_LOCATION_RIGHT = 2;
}

message ObjectPositionItem {
    ItemLocation item_location = 1;
}

message ObjectPositionStaging {
}

message ObjectPositionHand {
    PlayerName owner = 1;
}

message ObjectPositionDeck {
    PlayerName owner = 1;
}

message ObjectPositionDeckContainer {
    PlayerName owner = 1;
}

message ObjectPositionDiscardPile {
    PlayerName owner = 1;
}

message ObjectPositionDiscardPileContainer {
    PlayerName owner = 1;
}

/** 
 * Large display of cards *while* the score animation is playing. After the
 * score animation finishes, scored cards move to 'Identity' position.
 */
message ObjectPositionScoreAnimation {
}

message ObjectPositionRaid {
}

message ObjectPositionBrowser {
}

message ObjectPositionIdentity {
    PlayerName owner = 1;
}

message ObjectPositionIdentityContainer {
    PlayerName owner = 1;
}

message ObjectPositionRewardChest {
}

message ObjectPosition {
    /**
     * Optionally, a key by which to sort this object. If not provided, the
     * object will be appended to the end of the list (which is typically the
     * 'top' of the display).
     */
     google.protobuf.UInt32Value sorting_key = 1;
    
    oneof position {
        ObjectPositionOffscreen offscreen = 2;
        ObjectPositionRoom room = 3;
        ObjectPositionItem item = 4;
        ObjectPositionStaging staging = 5;
        ObjectPositionHand hand = 6;
        ObjectPositionDeck deck = 7;
        ObjectPositionDeckContainer deck_container = 8;
        ObjectPositionDiscardPile discard_pile = 9;
        ObjectPositionDiscardPileContainer discard_pile_container = 10;
        ObjectPositionScoreAnimation score_animation = 11;
        ObjectPositionRaid raid = 12;
        ObjectPositionBrowser browser = 13;
        ObjectPositionIdentity identity = 14;
        ObjectPositionIdentityContainer identity_container = 15;
    }
}

message RevealedCardView {
    SpriteAddress card_frame = 1;
    SpriteAddress title_background = 2;
    SpriteAddress jewel = 3;
    SpriteAddress image = 4;
    CardTitle title = 5;
    RulesText rules_text = 6;

    /**
     * True if this card should be displayed as visible to the opponent when in
     * the arena.
     */
    bool revealed_in_arena = 7;

    /**
    * Custom targeting behavior for a card. If unspecified, no targeting UI
    * is shown.
    */
    CardTargeting targeting = 8;

    /**
    * Where to move a played card. Information from 'targeting' will be
    * incorporated to fill this in, e.g. if a room is targeted and
    * ObjectPositionRoom is selected here with no RoomId, the targeted room
    * is used.
    */
    ObjectPosition on_release_position = 9;

    /** Information needed to determine whether a card can be played. */
    CardCost cost = 10;

    /** 
     * Additional interface element rendered to the side of the card during an
     * info zoom.
     */
    Node supplemental_info = 11;
}

message CardView {
    CardId card_id = 1;

    CardIcons card_icons = 2;

    SpriteAddress arena_frame = 3;

    /** Used to e.g. determine which card back to display for this card. */
    PlayerName owning_player = 4;

    RevealedCardView revealed_card = 5;
}

message HandView {
    repeated CardView cards = 1;
}

message DiscardPileView {
    repeated CardView cards = 1;
}

message PlayerInfo {
    string name = 1;
    SpriteAddress portrait = 2;
    SpriteAddress portrait_frame = 3;
    /** Card back asset to use for this player's cards. */
    SpriteAddress card_back = 4;
}

message ManaView {
    uint32 amount = 1;
}

message ScoreView {
    uint32 score = 1;
}

message RoomView {
    RoomId room_id = 1;
    repeated CardView back_cards = 2;
    repeated CardView front_cards = 3;
}

enum IdentityAction {
    IDENTITY_ACTION_UNSPECIFIED = 0;
    IDENTITY_ACTION_INITIATE_RAID = 1;
    IDENTITY_ACTION_LEVEL_UP_ROOM = 2;
}

message ArenaView {
    /**
    * If true, render rooms at the bottom of the screen, if false, render items
    * at the bottom.
    */
    google.protobuf.BoolValue rooms_at_bottom = 1;

    /**
     * Controls the drag action taken for the player's identity card.
     */
    IdentityAction identity_action = 2;
}

message ActionTrackerView {
    uint32 available_action_count = 1;
}

message DeckView {
    repeated CardView top_cards = 1;
}

message PlayerView {
    PlayerInfo player_info = 1;
    ScoreView score = 2;
    ManaView mana = 3;
    ActionTrackerView action_tracker = 4;
}

message GameView {
    GameId game_id = 1;
    PlayerView user = 2;
    PlayerView opponent = 3;
    ArenaView arena = 4;
    /** The player who is currently able to act. */
    PlayerName current_priority = 5;
}


// ============================================================================
// Actions
// ============================================================================

/** 
 * Start a game. If game_id is provided, connects to an ongoing game.
 * Otherwise creates a new game.
 */
message ConnectAction {
    GameId game_id = 1;
}

message StandardAction {
    /** Opaque payload to send to the server. */
    google.protobuf.Any payload = 1;

    /** Immediate optimistic mutations to game state for this action. */
    CommandList update = 2;
}

/**
* Spend an action to gain 1 mana.
*
* Optimistic: Mana is added immediately.
*/
message GainManaAction {
}

/**
* Spend an action to draw a card.
*
* Optimistic: Face-down card animates to reveal area.
*/
message DrawCardAction {
}

/**
* Spend an action to level up a room.
*
* Optimistic: Counter is added immediately
*/
message LevelUpRoomAction {
    RoomId room_id = 1;
}

message CardTarget {
    oneof card_target {
        RoomId room_id = 1;
    }
}

/**
* Spend an action to play a card from hand.
*
* Optimistic:
*   - Mana and action cost is spent immediately, and 'can play' values for
*     other cards in hand are optimistically updated
*   - Other costs like 'sacrifice an artifact' are not optimistic and are
*     handled like choices
*   - Targeted cards select their *first* valid target (cards, rooms, players)
*     optimistically. If additional targets are required, they're not handled
*     optimistically, and this play pattern should possibly be avoided.
*   - Cards that require a choice to be made before resolving do not display
*     the options optimistically, instead they animate to the reveal card area
*   - Item cards which don't require a choice to be made or target simply
*     animate into the play area optimistically
*   - Spell cards animate to the reveal card area and wait for their effects to
*     be applied
*   - Minion and Project cards animate to their selected room optimistically
*/
message PlayCardAction {
    CardId card_id = 1;
    CardTarget target = 2;
}

/**
* Spend an action to initiate a raid on one of the overlord's rooms
*
* Optimistic: Raid start animation plays
*/
message InitiateRaidAction {
    RoomId room_id = 1;
}

/**
* Possible game actions taken by the user.
*
* Actions have an associated 'optimistic' behavior to display while waiting
* for a server response. The client should not send multiple actions at the
* same time -- interaction should be disabled while an action is pending.
*/
message GameAction {
    oneof action {
        StandardAction standard_action = 1;
        ConnectAction connect = 2;
        GainManaAction gain_mana = 3;
        DrawCardAction draw_card = 4;
        PlayCardAction play_card = 5;
        LevelUpRoomAction level_up_room = 6;
        InitiateRaidAction initiate_raid = 7;
    }
}

message GameRequest {
    GameAction action = 1;
    
    /** Current game_id, if a game is currently ongoing. */
    GameId game_id = 2;
}

// ============================================================================
// Commands
// ============================================================================

message DebugLogCommand {
    string message = 1;
}

/**
 * Run a series of command lists simultaneously. Warning: applying multiple
 * commands to the same game object will have unpredictable results.
 */
message RunInParallelCommand {
    repeated CommandList commands = 1;
}

/** Wait before executing the next command in sequence. */
message DelayCommand {
    TimeValue duration = 1;
}

message InterfacePositionFullScreen {
    Node node = 1;
}

message InterfacePositionMainControls {
    Node node = 1;
}

enum CardNodeAnchorPosition {
    CARD_NODE_ANCHOR_POSITION_UNSPECIFIED = 0;

    CARD_NODE_ANCHOR_POSITION_BOTTOM = 1;

    CARD_NODE_ANCHOR_POSITION_LEFT = 2;

    CARD_NODE_ANCHOR_POSITION_RIGHT = 3;
}

/** Render an interface element attached to a specific card. */
message CardAnchorNode {
    CardId card_id = 1;
    Node node = 2;
    CardNodeAnchorPosition anchor_position = 3;
}

message InterfacePositionCardAnchors {
    repeated CardAnchorNode anchor_nodes = 1;
}

/**
* Updates the content of the user interface to display the provided node,
* replacing all existing UI elements.
*/
message RenderInterfaceCommand {
    oneof position {
        InterfacePositionFullScreen full_screen = 1;
        InterfacePositionMainControls main_controls = 2;
        InterfacePositionCardAnchors card_anchors = 3;
    }
}

/**
* Many of the below commands are specific cases of RenderGame. They are
* differentiated in order to simplify the diffing logic the client needs
* to perform to detect and animate changes.
*/
message UpdateGameViewCommand {
    GameView game = 1;
}

message InitiateRaidCommand {
    PlayerName initiator = 1;
    RoomId room_id = 2;
}

/**
 * Removes the raid UI overlay. This command does not cause game objects within
 * the raid to change position, 'MoveGameObjectCommand' should be used for that
 * instead.
 */
message EndRaidCommand {
    PlayerName initiator = 1;
}

/**
 * Animates 'initiator' moving to a room and plays a standard effect.
 */
message LevelUpRoomCommand {
    PlayerName initiator = 1;
    RoomId room_id = 2;
}

enum CardCreationAnimation {
    CARD_CREATION_ANIMATION_UNSPECIFIED = 0;

    /** Animates the card moving from the deck to the staging area. */
    CARD_CREATION_ANIMATION_DRAW_CARD = 1;
}

/**
 * Creates a new card, or updates an existing card if one is already present
 * with the provided CardId.
 *
 * When a user takes the 'draw card' game action, an optimistically-created
 * card is constructed and animated to the staging area face down. If an
 * optimistically-created card is found, that card is updated with the 'card'
 * value here instead.
 */
message CreateOrUpdateCardCommand {
    CardView card = 1;

    /** 
     * Optionally, a position in which to create this card. Ignored if the
     * card already exists. Ignored during optimistic card draw.
     */
    ObjectPosition create_position = 2;

    /** 
     * Optionally, an animation to play after creating the card. Ignored if
     * the card already exists. Ignored during optimistic card draw.
     */
    CardCreationAnimation create_animation = 3;

    /**
    * Disables the flip animation for this card, allowing it immediately
    * transition to a revealed state.
    */
    bool disable_flip_animation = 4;
}

/**
 * Moves a list of GameObjects to a new position. Objects already in the target
 * position are skipped.
 */
message MoveGameObjectsCommand {
    repeated GameObjectId ids = 1;

    /**
     * Position at which to insert. If multiple IDs are specified, they will
     * be sequentially added at this position
     */    
    ObjectPosition position = 2;
    
    bool disable_animation = 3;
}

/** 
 * Request to move all GameObjects located at a specific object position to
 * another object position.
 */
message MoveGameObjectsAtPositionCommand {
    ObjectPosition source_position = 1;

    ObjectPosition target_position = 2;

    bool disable_animation = 3;
}

message PlaySoundCommand {
    AudioClipAddress sound = 1;
}

enum MusicState {
    MUSIC_STATE_UNSPECIFIED = 0;
    MUSIC_STATE_SILENT = 1;
    MUSIC_STATE_GAMEPLAY = 2;
    MUSIC_STATE_RAID = 3;
}

message SetMusicCommand {
    MusicState music_state = 1;
}

/**
 * Fire a projectile from one game object at another.
 */
message FireProjectileCommand {
    GameObjectId source_id = 1;
    GameObjectId target_id = 2;

    /** Projectile to fire from the 'source_id' card to 'target_id' */
    ProjectileAddress projectile = 3;

    /** How long the projectile should take to hit its target. */
    TimeValue travel_duration = 4;

    AudioClipAddress fire_sound = 5;

    AudioClipAddress impact_sound = 6;

    /** Additional effect to display on the target on hit. */
    EffectAddress additional_hit = 7;

    /**
     * Delay before showing the additional hit. If provided, the original
     * projectile Hit effect will be hidden before showing the new hit effect.
     */
    TimeValue additional_hit_delay = 8;

    /**
     * During to wait for the project's impact effect before continuing
     */
    TimeValue wait_duration = 9;

    /**
     * If true, the target will be hidden after being hit during the
     * 'wait_duration' and before jumping to 'jump_to_position'.
     */
    bool hide_on_hit = 10;

    /**
     * Position for the target to jump to after being hit.
     */
    ObjectPosition jump_to_position = 11;
}

message PlayEffectPosition {
    oneof effect_position {
        GameObjectId game_object = 1;
    }
}

message PlayEffectCommand {
    EffectAddress effect = 1;

    PlayEffectPosition position = 2;

    google.protobuf.FloatValue scale = 3;

    /** How long to wait before continuing. */
    TimeValue duration = 4;

    AudioClipAddress sound = 5;
}

enum GameMessageType {
    GAME_MESSAGE_TYPE_UNSPECIFIED = 0;
    GAME_MESSAGE_TYPE_DAWN = 1;
    GAME_MESSAGE_TYPE_DUSK = 2;
    GAME_MESSAGE_TYPE_VICTORY = 3;
    GAME_MESSAGE_TYPE_DEFEAT = 4;
}

message DisplayGameMessageCommand {
    GameMessageType message_type = 1;
}

/** Used to hide and show all game UI elements. */
message SetGameObjectsEnabledCommand {
    bool game_objects_enabled = 1;
}

message DisplayRewardsCommand {
    repeated CardView rewards = 1;
}

message GameCommand {
    oneof command {
        DebugLogCommand debug_log = 1;
        RunInParallelCommand run_in_parallel = 2;
        DelayCommand delay = 3;
        RenderInterfaceCommand render_interface = 4;
        UpdateGameViewCommand update_game_view = 5;
        InitiateRaidCommand initiate_raid = 6;
        EndRaidCommand end_raid = 7;
        LevelUpRoomCommand level_up_room = 8;
        CreateOrUpdateCardCommand create_or_update_card = 9;
        MoveGameObjectsCommand move_game_objects = 11;
        MoveGameObjectsAtPositionCommand move_objects_at_position = 12;
        PlaySoundCommand play_sound = 13;
        SetMusicCommand set_music = 14;
        FireProjectileCommand fire_projectile = 15;
        PlayEffectCommand play_effect = 16;
        DisplayGameMessageCommand display_game_message = 17;
        SetGameObjectsEnabledCommand set_game_objects_enabled = 18;
        DisplayRewardsCommand display_rewards = 19;
    }
}

message CommandList {
    repeated GameCommand commands = 1;
}

service Spelldawn {
    // Our SayHello rpc accepts HelloRequests and returns HelloReplies
    rpc PerformAction(GameRequest) returns (CommandList);
}