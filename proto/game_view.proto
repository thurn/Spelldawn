// Copyright Â© Spelldawn 2021-present

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//    https://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package sd;
option csharp_namespace = "Spelldawn.Protos";

import "masonry.proto";
import "game_primitives.proto";

message CardIcon {
  sd.SpriteAddress background = 1;
  string text = 2;
  bool show_in_arena = 3;
}

message CardIcons {
  CardIcon top_left_icon = 1;
  CardIcon top_right_icon = 2;
  CardIcon bottom_right_icon = 3;
  CardIcon bottom_left_icon = 4;
  CardIcon center_icon = 5;
}

message CardTitle {
  string text = 1;
}

message RulesText {
  string text = 1;
}

enum TargetingArrow {
  TARGETING_ARROW_UNSPECIFIED = 0;
  TARGETING_ARROW_RED = 1;
  TARGETING_ARROW_BLUE = 2;
  TARGETING_ARROW_GREEN = 3;
}

message PickCard {
  repeated CardId valid_targets = 1;

  TargetingArrow targeting_arrow = 2;
}

message PickRoom {
  repeated RoomId valid_rooms = 2;
}

message CardTargeting {
  oneof targeting {
    /** Pick one of these cards via an arrow on drag. */
    PickCard pick_card = 1;

    /** Pick one of these valid rooms. */
    PickRoom pick_room = 2;
  }
}

enum CanPlayAlgorithm {
  CAN_PLAY_ALGORITHM_UNSPECIFIED = 0;

  /**
   * Always update the 'can_play' state automatically based on available mana
   * and actions.
   */
  CAN_PLAY_ALGORITHM_OPTIMISTIC = 1;

  /**
   * 'Optimistic False' algorithm for cards with an additional cost. Will
   * transition the 'can_play' state to false based on available mana and
   * actions, but not to true.
   */
  CAN_PLAY_ALGORITHM_ADDITIONAL_COST = 2;

  /**
   * 'Optimistic True' algorithm, for cards which can always be played for
   * their normal cost, but have other valid play windows as well. Will
   * transition the 'can_play' state to true based on available mana and
   * actions, but not to false.
   */
   CAN_PLAY_ALGORITHM_ADDITIONAL_PLAY = 3;

  /**
   * Do not transition the 'can_play' state automatically
   */
  CAN_PLAY_ALGORITHM_NO_UPDATE = 4;
}

enum SpendCostAlgorithm {
  SPEND_COST_ALGORITHM_UNSPECIFIED = 0;

  /** Deduct the mana & action cost immediately when this card is played. */
  SPEND_COST_ALGORITHM_OPTIMISTIC = 1;

  /** Do not modify mana & action values when this card is played. */
  SPEND_COST_ALGORITHM_NO_UPDATE = 2;
}

message CardCost {
  int32 mana_cost = 1;

  int32 action_cost = 2;

  bool can_play = 3;

  CanPlayAlgorithm can_play_algorithm = 4;

  SpendCostAlgorithm spend_cost_algorithm = 5;
}

enum RoomLocation {
  ROOM_LOCATION_UNSPECIFIED = 0;
  ROOM_LOCATION_IN_ROOM = 1;
  ROOM_LOCATION_DEFENDER = 2;
}

message CardPositionRoom {
  RoomId room_id = 1;
  RoomLocation room_location = 2;
}

enum ItemLocation {
  ITEM_LOCATION_UNSPECIFIED = 0;
  ITEM_LOCATION_LEFT = 1;
  ITEM_LOCATION_RIGHT = 2;
}

message CardPositionItem {
  ItemLocation item_location = 1;
}

message CardPositionStaging {
}

message CardPositionHand {
  PlayerName owner = 1;
}

message CardPositionDeck {
  PlayerName owner = 1;
}

message CardPositionDiscard {
  PlayerName owner = 1;
}

message CardPositionScored {
  PlayerName owner = 1;
}

message CardPositionBrowser {
}

message CardPosition {
  oneof position {
    CardPositionRoom room = 1;
    CardPositionItem item = 2;
    CardPositionStaging staging = 3;
    CardPositionHand hand = 4;
    CardPositionDeck deck = 5;
    CardPositionDiscard discard = 6;
    CardPositionScored scored = 7;
    CardPositionBrowser browser = 8;
  }
}

message RevealedCardView {
  sd.SpriteAddress card_frame = 1;
  sd.SpriteAddress title_background = 2;
  sd.SpriteAddress jewel = 3;
  sd.SpriteAddress image_background = 4;
  sd.SpriteAddress image = 5;
  CardTitle title = 6;
  RulesText rules_text = 7;

  /**
   * Custom targeting behavior for a card. If unspecified, no targeting UI
   * is shown.
   */
  CardTargeting targeting = 8;

  /**
   * Where to move a played card. Information from 'targeting' will be
   * incorporated to fill this in, e.g. if a room is targeted and
   * CardPositionRoom is selected here with no RoomId, the targeted room
   * is used.
   */
  CardPosition on_release_position = 9;

  /** Information needed to determine whether a card can be played. */
  CardCost cost = 10;
}

message CardView {
  CardId card_id = 1;
  CardPosition on_create_position = 2;
  sd.SpriteAddress card_back = 3;
  CardIcons card_icons = 4;
  sd.SpriteAddress arena_frame = 5;
  RevealedCardView revealed_card = 6;
}

message HandView {
  repeated CardView cards = 1;
}

message DiscardPileView {
  repeated CardView cards = 1;
}

message PlayerInfo {
  string name = 1;
  sd.SpriteAddress portrait = 2;

  /**
   * Identifies the player's unique powers. The back for this card is used
   * as the card back for all of this player's cards. The CardIds of the
   * user's and the opponent's identity cards are conventionally 1 and 2.
   */
  CardView identity_card = 3;
}

message ManaView {
  int32 amount = 1;
}

message ScoreView {
  int32 score = 1;
  repeated CardView scored_cards = 2;
}

message RoomInfo {
  sd.SpriteAddress room_icon = 1;
}

message RoomView {
  RoomId room_id = 1;
  RoomInfo room_info = 2;
  repeated CardView cards = 3;
}

message ArenaView {
  /**
   * If true, render rooms at the bottom of the screen, if false, render items
   * at the bottom.
   */
  bool overlord_perspective = 1;

  repeated RoomView rooms = 2;
  repeated CardView items = 3;
}

message ActionTrackerView {
  int32 available_action_count = 1;
}

message DeckView {
}

message PlayerView {
  PlayerInfo player_info = 1;
  ScoreView score = 2;
  HandView hand = 3;
  ManaView mana = 4;
  DiscardPileView discard_pile = 5;
  ActionTrackerView action_tracker = 6;
  DeckView deck = 7;
}

message GameView {
  PlayerView user = 1;
  PlayerView opponent = 2;
  ArenaView arena = 3;
}
